
R version 2.4.0 Under development (unstable) (2006-08-22 r38955)
Copyright (C) 2006 The R Foundation for Statistical Computing
ISBN 3-900051-07-0

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> require("mboost")
Loading required package: mboost
Loading required package: modeltools
Loading required package: party
Loading required package: survival
Loading required package: splines
Loading required package: grid
Loading required package: coin
Loading required package: mvtnorm
Loading required package: zoo

Attaching package: 'zoo'


	The following object(s) are masked from package:base :

	 rapply 

Loading required package: sandwich
Loading required package: strucchange
[1] TRUE
> 
> set.seed(290875)
> 
> dgp <- function(n = 100, beta = rep(0, 10), sd = 1) {
+     p <- length(beta) - 1
+     x <- cbind(1, matrix(runif(n * p), ncol = p))
+     lp <- x %*% beta
+     y <- lp + rnorm(n, sd = sd)
+     ls <- data.frame(y = y, x[,-1])
+     attr(ls, "lp") <- lp
+     ls
+ }
> 
> ### well-defined problem
> mydf <- dgp(beta = c(1, 2.5, rep(0, 2)))
> 
> ### for easy comparison with lm
> fm <- GaussReg()
> fm@offset <- function(y, w) 0
> 
> mydf.gb <- glmboost(y ~ ., data = mydf, family = fm, 
+                     control = boost_control(mstop = 10000))
> mydf.lm <- lm(y ~ ., data = mydf)
> 
> ### compare coefficients
> stopifnot(max(abs(coef(mydf.gb) - coef(mydf.lm))) < 1e-10)
> 
> ### a little bit more difficult
> mydf <- dgp(beta = c(1, 2.5, rep(0, 38)))
> 
> mydf.gb <- glmboost(y ~ ., data = mydf, family = fm, 
+                     control = boost_control(mstop = 10000))
> aic <- AIC(mydf.gb, method = "corrected")
> mstop(aic)
[1] 374
> mydf.lm <- lm(y ~ ., data = mydf)
> 
> ### compare coefficients
> which(abs(coef(mydf.lm)) < abs(coef(mydf.gb[mstop(aic)])))
(Intercept) 
          1 
> 
> #### check boosting hat matrix and subsetting / predict
> stopifnot(isTRUE(all.equal(drop(attr(aic, "hatmat") %*% mydf$y),
+                            as.vector(predict(mydf.gb)))))
> stopifnot(isTRUE(all.equal(drop(attr(AIC(mydf.gb[255]), "hatmat") %*% mydf$y),
+                            as.vector(predict(mydf.gb[255])))))
> stopifnot(isTRUE(all.equal(drop(attr(AIC(mydf.gb[255]), "hatmat") %*% mydf$y),
+                            as.vector(fitted(mydf.gb[255])))))
> 
> ### a simple two-dimensional example from `glmboost.Rd'
> data("cars")
> cars.gb <- glmboost(dist ~ speed, data = cars, family = fm, 
+                     control = boost_control(mstop = 5000))
> cars.gb

	 Generalized Linear Models Fitted via Gradient Boosting) 

Call:
glmboost.formula(formula = dist ~ speed, data = cars, family = fm,     control = boost_control(mstop = 5000))


	 Squared Error (Regression) 

Loss function: (y - f)^2 
 

Number of boosting iterations: mstop = 5000 
Step size:  0.1 

Coefficients: 
(Intercept)       speed 
 -17.579079    3.932408 

> 
> ### coefficients should coincide
> coef(cars.gb)
(Intercept)       speed 
 -17.579079    3.932408 
> coef(lm(dist ~ speed, data = cars))
(Intercept)       speed 
 -17.579095    3.932409 
> 
> ### logistic regression
> mydf <- data.frame(x = runif(100), y = gl(2, 50))
> bmod <- glmboost(y ~ x, data = mydf, family = Binomial(), 
+                  control = boost_control(mstop = 10000))
> gmod <- glm(y ~ x, data = mydf, family = binomial())
> llg <- logLik(gmod)
> attributes(llg) <- NULL
> stopifnot(all.equal(logLik(bmod), llg))
> stopifnot(max(abs(predict(gmod, type = "link")/2 - fitted(bmod))) < 
+                   sqrt(.Machine$double.eps))
> stopifnot(all.equal(coef(bmod) * 2, coef(gmod)))
> 
> ### weighted least squares problem
> 
> x <- runif(100)  
> df <- data.frame(y = 2 + 3 * x + rnorm(length(x)),
+                  x = x, z = runif(length(x)),
+                  w = runif(length(x)) * 10)
> 
> ### linear model, classical fit
> lmmod <- lm(y ~ x + z, data = df, weights = w)
> 
> ### linear model, boosting fit
> lmb <- glmboost(y ~ x + z, data = df, weights = df$w,
+                 control = boost_control(mstop = 20000))
> 
> ### compare fitted values
> stopifnot(max(abs(fitted(lmmod) -fitted(lmb))) < sqrt(.Machine$double.eps))
> 
> ### compare hat matrices
> stopifnot(max(abs(hatvalues(lmmod) - hatvalues(lmb))) < sqrt(.Machine$double.eps))      
> 
> ### compare boosting hat matrix with fitted values
> stopifnot(max(abs(attr(AIC(lmb), "hatmatrix") %*% (df$y - lmb$offset) + lmb$offset -
+         fitted(lmb))) < sqrt(.Machine$double.eps)) 
> 
> ### Cox model (check for CoxPH family)
> if (require("survival")) {
+ 
+     test <- data.frame(time = c(1, 2, 5, 2, 1, 7, 3, 4, 8, 8),
+                        event = c(1, 1, 1, 1, 1, 1, 1, 0, 0, 0),
+                        x     = c(1, 0, 0, 1, 0, 1, 1, 1, 0, 0))
+ 
+     stopifnot(all.equal(coef(cx <- coxph(Surv(time, event) ~ x, data = test, method = "breslow")),
+                        coef(gl <- glmboost(Surv(time, event) ~ x, data = test,
+                        family = CoxPH(), 
+                        control = boost_control(mstop = 1000)))[2]))
+ 
+     stopifnot(all.equal(cx$loglik[2], logLik(gl)))
+ 
+     indx <- c(1, 1, 1, 2:10)
+     w <- tabulate(indx)
+ 
+     stopifnot(all.equal(coef(cx <- coxph(Surv(time, event) ~ x, data = test, weights = w, 
+                                    method = "breslow")),
+                        coef(gl <- glmboost(Surv(time, event) ~ x, data = test, weights = w,
+                        family = CoxPH(), 
+                        control = boost_control(mstop = 1000)))[2]))
+ 
+     stopifnot(all.equal(cx$loglik[2], logLik(gl)))
+ 
+     indx <- c(1, 1, 1, 3:10)
+     w <- tabulate(indx)
+ 
+     stopifnot(all.equal(coef(cx <- coxph(Surv(time, event) ~ x, data = test[indx,], 
+                                    method = "breslow")),
+                        coef(gl <- glmboost(Surv(time, event) ~ x, data = test, weights = w,
+                        family = CoxPH(), 
+                        control = boost_control(mstop = 1000)))[2]))
+ 
+     stopifnot(all.equal(cx$loglik[2], logLik(gl)))
+ }
> 
