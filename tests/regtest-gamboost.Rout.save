
R : Copyright 2006, The R Foundation for Statistical Computing
Version 2.3.0 (2006-04-24)
ISBN 3-900051-07-0

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
> require("mboost")
Loading required package: mboost
Loading required package: modeltools
Loading required package: party
Loading required package: survival
Loading required package: splines
Loading required package: grid
Loading required package: coin
Loading required package: mvtnorm
Loading required package: zoo
Loading required package: sandwich
Loading required package: strucchange
[1] TRUE
> 
> set.seed(290875)
> 
> ### for boosting hat matrix checks
> fm <- GaussReg()
> fm@offset <- function(y, w) 0
> 
> ### a simple two-dimensional example from `gamboost.Rd'
> data("cars")
> cars.gb <- gamboost(dist ~ speed, data = cars, df = 4, family = fm,
+                     control = boost_control(mstop = 50))
> cars.gb

	 Generalized Additive Models Fitted via Gradient Boosting

Call:
gamboost.formula(formula = dist ~ speed, data = cars, df = 4,     family = fm, control = boost_control(mstop = 50))


	 Squared Error (Regression) 

Loss function: (y - f)^2 
 

Number of boosting iterations: mstop = 50 
Step size:  0.1 
Degree of freedom:  4 

> aic <- AIC(cars.gb, method = "corrected")
> aic
[1] 6.605535
Optimal number of boosting iterations: 35 
Degrees of freedom (for mstop = 35): 5.117497 
> 
> ### plot fit
> plot(dist ~ speed, data = cars)
> lines(cars$speed, predict(cars.gb[mstop(AIC(cars.gb))]), col = "red")
> lines(cars$speed, predict(smooth.spline(cars$speed, cars$dist), cars$speed)$y, 
+       col = "green")
> 
> #### check boosting hat matrix and subsetting / predict
> stopifnot(isTRUE(all.equal(drop(attr(aic, "hatmat") %*% cars$dist),
+                            as.vector(predict(cars.gb)))))
> stopifnot(isTRUE(all.equal(drop(attr(AIC(cars.gb[25]), "hatmat") %*% cars$dist),
+                            as.vector(predict(cars.gb[25])))))
> stopifnot(isTRUE(all.equal(drop(attr(AIC(cars.gb[25]), "hatmat") %*% cars$dist),
+                            as.vector(fitted(cars.gb[25])))))
> 
> ### check boosting hat matrix with multiple independent variables
> ### and weights
> data("bodyfat", package = "mboost")
> bffm <- DEXfat ~ age + waistcirc + hipcirc + elbowbreadth + kneebreadth +
+       anthro3a + anthro3b + anthro3c + anthro4 - 1
> indep <- names(bodyfat)[names(bodyfat) != "DEXfat"]
> bodyfat[indep] <- lapply(bodyfat[indep], function(x) x - mean(x))
> bf_gam <- gamboost(bffm, data = bodyfat, control = boost_control(mstop = 10), 
+                    weights = runif(nrow(bodyfat)) * 10)
> aic <- AIC(bf_gam)
> 
> off <- bf_gam$offset
> u <- bf_gam$ustart
> 
> stopifnot(isTRUE(all.equal(drop(attr(aic, "hatmat") %*% u + off),
+                            as.vector(predict(bf_gam)))))
> stopifnot(isTRUE(all.equal(drop(attr(aic, "hatmat") %*% u + off),
+                            as.vector(fitted(bf_gam)))))
> 
